<!DOCTYPE html><html lang="zh-TW"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>網絡對戰棋類遊戲</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --board-size: min(65vw, 65vh);
            --cell-size: calc(var(--board-size) / 8);
            --piece-size: calc(var(--cell-size) * 0.8);
        }

        .dark-mode {
            --light-square: #555555;
            --dark-square: #333333;
            --highlight: rgba(255, 255, 100, 0.5);
            --text-color: #ffffff;
            --bg-color: #181818;
            --card-bg: #252525;
        }

        :root:not(.dark-mode) {
            --light-square: #ffce9e;
            --dark-square: #d18b47;
            --highlight: rgba(173, 216, 230, 0.7);
            --text-color: #333333;
            --bg-color: #ffffff;
            --card-bg: #f9f9f9;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow-x: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        #board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .cell.light {
            background-color: var(--light-square);
        }

        .cell.dark {
            background-color: var(--dark-square);
        }

        .cell.selected {
            background-color: var(--highlight);
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
        }

        .piece {
            width: var(--piece-size);
            height: var(--piece-size);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            cursor: grab;
            user-select: none;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #c30010);
            border: 2px solid #a00000;
        }

        .piece.blue {
            background: radial-gradient(circle at 30% 30%, #6b9fff, #0010c3);
            border: 2px solid #0000a0;
        }

        .piece:hover {
            transform: scale(1.05);
        }

        .game-info {
            background-color: var(--card-bg);
            border-radius: 0.5rem;
            transition: background-color 0.3s;
        }

        #connection-status {
            transition: color 0.3s;
        }

        #connection-status.connected {
            color: #10b981;
        }

        #connection-status.connecting {
            color: #f59e0b;
        }

        #connection-status.disconnected {
            color: #ef4444;
        }

        /* Animation for move */
        @keyframes movePiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .animate-move {
            animation: movePiece 0.3s ease-in-out;
        }

        /* Notification styles */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .notification.show {
            opacity: 1;
        }

        /* Responsive adjustments for iframe embedded environment */
        @media (max-width: 768px) {
            :root {
                --board-size: min(90vw, 50vh);
            }
            .game-container {
                flex-direction: column-reverse;
            }
            .game-info {
                width: 90vw;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-2">
    <div class="text-center mb-4">
        <h1 class="text-3xl font-bold mb-2">網絡對戰棋類遊戲</h1>
        <p class="text-sm mb-4">所有棋子移動方式相同（類似國際象棋中的皇后，可向任何方向移動任意格數）</p>
    </div>

    <div class="game-container flex flex-row justify-center items-start gap-4 w-full">
        <div id="board-container" class="flex justify-center">
            <div id="board-placeholder" class="border-3 border-gray-300 border-dashed flex items-center justify-center" style="width: 60vmin; height: 60vmin; display: flex;">
                <p class="text-center text-gray-500 p-8">連接成功後棋盤將會顯示在此處</p>
            </div>
            <div id="board" style="display: none;"></div>
        </div>

        <div class="game-info p-4 shadow-md w-80">
            <div class="mb-4">
                <h2 class="text-xl font-bold mb-2">遊戲房間</h2>
                <div class="flex flex-col gap-2">
                    <div class="flex items-center mb-2">
                        <span id="connection-status" class="disconnected mr-2">●</span>
                        <span id="status-text">尚未連接</span>
                    </div>
                    
                    <!-- 初始視窗 - 選擇創建或加入房間 -->
                    <div id="room-initial-view" class="flex flex-col gap-3">
                        <button id="create-room-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded text-lg">創建新房間</button>
                        <button id="show-join-view-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded text-lg mt-2">加入房間</button>
                    </div>
                    
                    <!-- 創建房間後的視窗 - 顯示房間ID -->
                    <div id="room-created-view" class="hidden flex flex-col gap-2">
                        <p class="mb-1 font-bold">房間ID（分享給對手）:</p>
                        <div class="flex mb-2">
                            <input type="text" id="my-room-id" readonly="" class="p-2 border rounded text-base flex-grow text-black bg-gray-100">
                            <button id="copy-room-id" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded ml-2">複製</button>
                        </div>
                        <button id="back-to-initial-btn" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded">取消</button>
                    </div>
                    
                    <!-- 加入房間的視窗 - 輸入房間ID -->
                    <div id="room-join-view" class="hidden flex flex-col gap-2">
                        <input type="text" id="room-id-input" placeholder="輸入房間ID" class="p-3 border rounded text-base w-full text-black">
                        <div class="flex gap-2">
                            <button id="join-room-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex-grow">確定</button>
                            <button id="back-from-join-btn" class="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded">返回</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mb-4">
                <h2 class="text-xl font-bold mb-2">遊戲資訊</h2>
                <div id="turn-info-container" class="relative p-3 mb-3 rounded-lg border-2 border-gray-300 bg-gray-100 dark:bg-gray-800 dark:border-gray-700 transition-all duration-300">
                    <p id="turn-info" class="text-lg font-bold text-center">等待連接...</p>
                </div>
                <p id="player-color" class="mb-2 font-semibold">您的顏色：尚未分配</p>
            </div>

            <div class="mb-4">
                <h2 class="text-xl font-bold mb-2">遊戲控制</h2>
                <button id="reset-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full">重置遊戲</button>
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark-mode');
        }

        // Game state
        const gameState = {
            board: Array(8).fill().map(() => Array(8).fill(null)),
            selectedCell: null,
            validMoves: [],
            currentTurn: 'red', // 'red' or 'blue'
            myColor: null,
            connected: false,
            peer: null,
            connection: null,
            isHost: false
        };

        // Dom elements
        const boardElement = document.getElementById('board');
        const resetBtn = document.getElementById('reset-btn');
        const turnInfo = document.getElementById('turn-info');
        const playerColor = document.getElementById('player-color');
        const connectionStatus = document.getElementById('connection-status');
        const statusText = document.getElementById('status-text');

        // Initialize the board
        function initializeBoard() {
            boardElement.innerHTML = '';
            
            // Create cells
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }

            // Reset game state
            gameState.board = Array(8).fill().map(() => Array(8).fill(null));
            gameState.selectedCell = null;
            gameState.validMoves = [];
            gameState.currentTurn = 'red';
            gameState.gameStarted = false;

            // Initially we don't place any pieces
            updateTurnInfo();
        }
        
        // Start the game and place pieces
        function startGame() {
            if (gameState.gameStarted) return;
            
            gameState.gameStarted = true;
            
            // Randomly assign colors when game starts
            // If we're the host, we decide and tell the other player
            // If we're not the host, we wait for the decision
            if (gameState.isHost) {
                // Random assignment - true means host is red, false means host is blue
                const hostIsRed = Math.random() >= 0.5;
                gameState.myColor = hostIsRed ? 'red' : 'blue';
                console.log(`Host assigned color: ${gameState.myColor}`);
                
                // Tell the other player about the color assignment
                if (gameState.connection) {
                    gameState.connection.send({
                        type: 'color-assignment',
                        hostIsRed: hostIsRed
                    });
                }
                
                // Update board orientation immediately for host
                setupInitialPieces();
                updateBoardOrientation();
            } else {
                // For non-host, pieces will be set up when color assignment is received
                console.log("非房主玩家等待顏色分配");
            }
            
            // Send start game message to peer
            if (gameState.connection) {
                gameState.connection.send({
                    type: 'start-game'
                });
            }
            
            updateTurnInfo();
            
            // Update player color display
            if (gameState.myColor) {
                const colorText = gameState.myColor === 'red' ? '紅色' : '藍色';
                playerColor.textContent = `您的顏色：${colorText}`;
            }
        }
        
        // Convert logical coordinates to visual coordinates based on player color
        function convertCoordinates(row, col) {
            if (gameState.myColor === 'red') {
                // If player is red, flip the board so red pieces are at the bottom
                return { row: 7 - row, col: col };
            } else {
                // For blue player or when color is not yet assigned, use original coordinates
                return { row, col };
            }
        }
        
        // Convert visual coordinates back to logical coordinates
        function reverseCoordinates(visualRow, visualCol) {
            if (gameState.myColor === 'red') {
                // If player is red, convert back from flipped coordinates
                return { row: 7 - visualRow, col: visualCol };
            } else {
                // For blue player or when color is not yet assigned, use original coordinates
                return { row: visualRow, col: visualCol };
            }
        }
        
        // Get cell element by row and col (with rotation based on player color)
        function getCellElement(row, col) {
            const { row: visualRow, col: visualCol } = convertCoordinates(row, col);
            return boardElement.querySelector(`[data-row="${visualRow}"][data-col="${visualCol}"]`);
        }
        
        // Set up the initial pieces on the board
        function setupInitialPieces() {
            console.log("設置初始棋子位置");
            
            // Clear the board first
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    gameState.board[row][col] = null;
                    const cell = getCellElement(row, col);
                    if (cell) {
                        const piece = cell.querySelector('.piece');
                        if (piece) {
                            cell.removeChild(piece);
                        }
                    }
                }
            }
            
            // Red pieces (row 0 and 1)
            for (let col = 0; col < 8; col++) {
                gameState.board[0][col] = 'red';
                gameState.board[1][col] = 'red';
            }
            
            // Blue pieces (row 6 and 7)
            for (let col = 0; col < 8; col++) {
                gameState.board[6][col] = 'blue';
                gameState.board[7][col] = 'blue';
            }
            
            // Update the visual board to match the logical state
            updateBoardDisplay();
        }

        // Place a piece on the board
        function placePiece(row, col, color) {
            gameState.board[row][col] = color;
            const cell = getCellElement(row, col);
            
            // Remove any existing piece
            const existingPiece = cell.querySelector('.piece');
            if (existingPiece) {
                cell.removeChild(existingPiece);
            }
            
            // Create new piece
            const piece = document.createElement('div');
            piece.className = `piece ${color}`;
            cell.appendChild(piece);
        }
        
        // Update the board for the player's color
        function updateBoardOrientation() {
            if (!gameState.myColor) return; // No color assigned yet
            
            const colorText = gameState.myColor === 'red' ? '紅色' : '藍色';
            showNotification(`您被隨機分配了${colorText}棋子，${colorText}棋子將在棋盤底部`);
            
            // Update the board display to reflect the player's perspective
            updateBoardDisplay();
            
            console.log(`玩家顏色: ${gameState.myColor} (已調整棋盤方向，您的棋子在底部)`);
        }
        
        // Update the visual board display after a rotation
        function updateBoardDisplay() {
            // Clear all pieces from UI
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const piece = cell.querySelector('.piece');
                if (piece) {
                    cell.removeChild(piece);
                }
            });
            
            // Redraw all pieces according to the game state
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const color = gameState.board[row][col];
                    if (color) {
                        placePiece(row, col, color);
                    }
                }
            }
        }

        // Handle cell click
        function handleCellClick(visualRow, visualCol) {
            // If not connected or not your turn, ignore clicks
            if (!gameState.connected || gameState.currentTurn !== gameState.myColor) {
                return;
            }
            
            // Convert visual coordinates back to logical coordinates
            const { row, col } = reverseCoordinates(visualRow, visualCol);
            
            // Get the cell content
            const cellContent = gameState.board[row][col];
            
            // Add debug info
            console.log(`點擊視覺座標: (${visualRow},${visualCol}), 邏輯座標: (${row},${col}), 內容: ${cellContent}, 我的顏色: ${gameState.myColor}`);
            
            // If a cell is already selected
            if (gameState.selectedCell) {
                // If clicked on a valid move cell
                if (isValidMove({row, col})) {
                    movePiece(gameState.selectedCell, {row, col});
                    clearSelection();
                } 
                // If clicked on own piece, select it
                else if (cellContent === gameState.myColor) {
                    clearSelection();
                    selectCell({row, col});
                } 
                // Otherwise clear selection
                else {
                    clearSelection();
                }
            } 
            // If no cell is selected and clicked on own piece
            else if (cellContent === gameState.myColor) {
                selectCell({row, col});
            }
        }

        // Select a cell and show valid moves
        function selectCell(cell) {
            gameState.selectedCell = cell;
            const cellElement = getCellElement(cell.row, cell.col);
            cellElement.classList.add('selected');
            
            // Calculate and show valid moves
            gameState.validMoves = calculateValidMoves(cell);
            gameState.validMoves.forEach(move => {
                const moveCell = getCellElement(move.row, move.col);
                moveCell.classList.add('valid-move');
            });
        }

        // Clear selected cell and valid moves
        function clearSelection() {
            if (gameState.selectedCell) {
                const cellElement = getCellElement(gameState.selectedCell.row, gameState.selectedCell.col);
                cellElement.classList.remove('selected');
            }
            
            gameState.validMoves.forEach(move => {
                const moveCell = getCellElement(move.row, move.col);
                moveCell.classList.remove('valid-move');
            });
            
            gameState.selectedCell = null;
            gameState.validMoves = [];
        }

        // Calculate valid moves for a piece (queen-like movement)
        function calculateValidMoves(cell) {
            const { row, col } = cell;
            const color = gameState.board[row][col];
            const moves = [];
            
            // Directions: horizontal, vertical, and diagonal
            const directions = [
                {dr: -1, dc: 0},  // up
                {dr: 1, dc: 0},   // down
                {dr: 0, dc: -1},  // left
                {dr: 0, dc: 1},   // right
                {dr: -1, dc: -1}, // up-left
                {dr: -1, dc: 1},  // up-right
                {dr: 1, dc: -1},  // down-left
                {dr: 1, dc: 1}    // down-right
            ];
            
            // Check each direction
            directions.forEach(dir => {
                let r = row + dir.dr;
                let c = col + dir.dc;
                
                // Continue in this direction until hitting a boundary or piece
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const cellContent = gameState.board[r][c];
                    
                    // If empty cell, it's a valid move
                    if (cellContent === null) {
                        moves.push({row: r, col: c});
                    } 
                    // If opponent's piece, can capture it (valid move) but can't go further
                    else if (cellContent !== color) {
                        moves.push({row: r, col: c});
                        break;
                    } 
                    // If own piece, can't move here or beyond
                    else {
                        break;
                    }
                    
                    r += dir.dr;
                    c += dir.dc;
                }
            });
            
            return moves;
        }

        // Check if a move is valid
        function isValidMove(cell) {
            return gameState.validMoves.some(move => move.row === cell.row && move.col === cell.col);
        }

        // Move a piece
        function movePiece(from, to) {
            console.log(`移動: 從(${from.row},${from.col}) 到 (${to.row},${to.col})`);
            
            const pieceColor = gameState.board[from.row][from.col];
            
            // Update game state
            gameState.board[from.row][from.col] = null;
            gameState.board[to.row][to.col] = pieceColor;
            
            // Update UI
            const fromCell = getCellElement(from.row, from.col);
            const toCell = getCellElement(to.row, to.col);
            
            // Remove any existing piece in the destination cell
            const existingPiece = toCell.querySelector('.piece');
            if (existingPiece) {
                toCell.removeChild(existingPiece);
            }
            
            // Move the piece element
            const piece = fromCell.querySelector('.piece');
            if (piece) {
                fromCell.removeChild(piece);
                toCell.appendChild(piece);
                
                // Add move animation
                piece.classList.add('animate-move');
                setTimeout(() => {
                    piece.classList.remove('animate-move');
                }, 300);
            } else {
                console.error("找不到要移動的棋子元素!");
                // 如果找不到DOM元素，至少創建一個新的
                const newPiece = document.createElement('div');
                newPiece.className = `piece ${pieceColor}`;
                toCell.appendChild(newPiece);
            }
            
            // Switch turns
            gameState.currentTurn = gameState.currentTurn === 'red' ? 'blue' : 'red';
            updateTurnInfo();
            
            // Send move to peer
            if (gameState.connection) {
                gameState.connection.send({
                    type: 'move',
                    from: from,
                    to: to
                });
            }
            
            // Check for win condition
            checkWinCondition();
        }

        // Check if a player has won
        function checkWinCondition() {
            let redCount = 0;
            let blueCount = 0;
            
            // Count pieces of each color
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (gameState.board[row][col] === 'red') {
                        redCount++;
                    } else if (gameState.board[row][col] === 'blue') {
                        blueCount++;
                    }
                }
            }
            
            // If a player has no pieces left, the other player wins
            if (redCount === 0) {
                showNotification('Blue wins!');
                updateTurnInfo('Blue wins!');
            } else if (blueCount === 0) {
                showNotification('Red wins!');
                updateTurnInfo('Red wins!');
            }
        }
        
        // Show notification instead of alert (for better iframe compatibility)
        function showNotification(message) {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.className = 'notification';
                document.body.appendChild(notification);
            }
            
            // Set message and show
            notification.textContent = message;
            notification.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Update turn information with more prominent display
        function updateTurnInfo(customMessage = null) {
            const turnInfoContainer = document.getElementById('turn-info-container');
            
            if (customMessage) {
                // Game over message
                turnInfo.textContent = customMessage.replace('Red wins!', '紅方勝利！').replace('Blue wins!', '藍方勝利！');
                turnInfoContainer.className = 'relative p-3 mb-3 rounded-lg border-2 border-yellow-500 bg-yellow-100 dark:bg-yellow-900 dark:border-yellow-600 transition-all duration-300';
                turnInfo.className = 'text-lg font-bold text-center text-yellow-800 dark:text-yellow-200';
            } else if (!gameState.connected) {
                // Waiting for connection
                turnInfo.textContent = '等待連接...';
                turnInfoContainer.className = 'relative p-3 mb-3 rounded-lg border-2 border-gray-300 bg-gray-100 dark:bg-gray-800 dark:border-gray-700 transition-all duration-300';
                turnInfo.className = 'text-lg font-bold text-center text-gray-600 dark:text-gray-300';
            } else {
                const isMyTurn = gameState.currentTurn === gameState.myColor;
                
                if (isMyTurn) {
                    // My turn - green with pulsing border
                    turnInfo.textContent = '▶️ 輪到您下棋！';
                    turnInfoContainer.className = 'relative p-3 mb-3 rounded-lg border-2 border-green-500 bg-green-100 dark:bg-green-900 dark:border-green-500 transition-all duration-300 animate-pulse';
                    turnInfo.className = 'text-xl font-bold text-center text-green-800 dark:text-green-200';
                } else {
                    // Opponent's turn - gray with no animation
                    turnInfo.textContent = '⏳ 等待對手下棋';
                    turnInfoContainer.className = 'relative p-3 mb-3 rounded-lg border-2 border-gray-400 bg-gray-100 dark:bg-gray-800 dark:border-gray-700 transition-all duration-300';
                    turnInfo.className = 'text-lg font-bold text-center text-gray-600 dark:text-gray-400';
                }
            }
            
            // Update player color display
            if (gameState.myColor) {
                const colorText = gameState.myColor === 'red' ? '紅色' : '藍色';
                playerColor.textContent = `您的顏色：${colorText}`;
                playerColor.className = `mb-2 font-semibold ${gameState.myColor === 'red' ? 'text-red-600 dark:text-red-400' : 'text-blue-600 dark:text-blue-400'}`;
            } else {
                playerColor.textContent = '您的顏色：尚未分配';
                playerColor.className = 'mb-2 font-semibold';
            }
        }

        // Update connection status
        function updateConnectionStatus(status, message) {
            connectionStatus.className = status;
            statusText.textContent = message;
            
            if (status === 'connected') {
                gameState.connected = true;
            } else {
                gameState.connected = false;
            }
            
            updateTurnInfo();
        }

        // Initialize PeerJS for P2P connection
        function initPeer() {
            // Generate a random peer ID
            const peerId = 'chess-' + Math.random().toString(36).substr(2, 9);
            
            gameState.peer = new Peer(peerId, {
                debug: 2
            });
            
            gameState.peer.on('open', (id) => {
                // Show the room created view with the ID
                document.getElementById('my-room-id').value = id;
                showRoomView('created');
                updateConnectionStatus('connecting', '房間已創建 - 等待對手加入');
            });
            
            gameState.peer.on('connection', (conn) => {
                // Only accept one connection
                if (gameState.connection) {
                    conn.close();
                    return;
                }
                
                setupConnection(conn);
                gameState.isHost = true;
                
                // Assign colors only when game starts
                gameState.myColor = null;
                updateTurnInfo();
                updateConnectionStatus('connected', '對手已加入 - 準備開始遊戲');
            });
            
            gameState.peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                updateConnectionStatus('disconnected', 'Connection error');
                showNotification('Connection error: ' + err.type);
            });
        }

        // Connect to a peer
        function connectToPeer(roomId) {
            if (!gameState.peer) {
                // Initialize our own peer first
                gameState.peer = new Peer(null, {
                    debug: 2
                });
                
                gameState.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    updateConnectionStatus('disconnected', 'Connection error');
                    showNotification('Connection error: ' + err.type);
                });
                
                // Wait for our peer to be ready before connecting
                gameState.peer.on('open', () => {
                    // Now connect to the room
                    const conn = gameState.peer.connect(roomId);
                    setupConnection(conn);
                    gameState.isHost = false;
                });
            } else {
                // If peer is already initialized, connect directly
                const conn = gameState.peer.connect(roomId);
                setupConnection(conn);
                gameState.isHost = false;
            }
            
            updateConnectionStatus('connecting', '正在加入房間...');
        }

        // Setup connection event handlers
        function setupConnection(conn) {
            gameState.connection = conn;
            
            conn.on('open', () => {
                updateConnectionStatus('connected', '已連接');
                
                // Hide placeholder and show actual board
                document.getElementById('board-placeholder').style.display = 'none';
                document.getElementById('board').style.display = 'grid';
                
                // Initialize the board with cells (but no pieces yet)
                initializeBoard();
                
                // Auto-start game after connection is established
                setTimeout(() => {
                    startGame();
                }, 800);
            });
            
            conn.on('data', (data) => {
                handlePeerMessage(data);
            });
            
            conn.on('close', () => {
                updateConnectionStatus('disconnected', '已斷開連接');
                gameState.connection = null;
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
                updateConnectionStatus('disconnected', 'Connection error');
            });
        }

        // Handle messages from peer
        function handlePeerMessage(data) {
            console.log("收到消息:", data);
            
            if (data.type === 'move') {
                const { from, to } = data;
                
                console.log(`收到移動消息: 從(${from.row},${from.col}) 到 (${to.row},${to.col})`);
                
                // Update game state
                gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                gameState.board[from.row][from.col] = null;
                
                // Update UI - completely redraw the board to ensure correct state
                updateBoardDisplay();
                
                // Switch turns
                gameState.currentTurn = gameState.currentTurn === 'red' ? 'blue' : 'red';
                updateTurnInfo();
                
                // Check for win condition
                checkWinCondition();
            } else if (data.type === 'color-assignment') {
                console.log("收到顏色分配消息:", data);
                // Received color assignment from host
                gameState.myColor = data.hostIsRed ? 'blue' : 'red';
                
                // Notify the player about their color
                const colorText = gameState.myColor === 'red' ? '紅色' : '藍色';
                playerColor.textContent = `您的顏色：${colorText}`;
                showNotification(`您被隨機分配了${colorText}棋子，${colorText}棋子將在棋盤底部`);
                
                // For non-host player, set up initial pieces after receiving color assignment
                setupInitialPieces();
                
                // Update the board view based on player's color after a brief delay
                setTimeout(() => {
                    updateBoardOrientation();
                }, 100);
            } else if (data.type === 'reset-request') {
                // We've received a reset request from the opponent
                pendingResetRequest = true;
                
                // Show reset request to user
                showConfirmation('對手請求重置遊戲，您同意嗎？', () => {
                    // User has agreed to the reset request
                    pendingResetRequest = false;
                    
                    // Reset the game
                    initializeBoard();
                    
                    // Send confirmation back to opponent
                    if (gameState.connection) {
                        gameState.connection.send({
                            type: 'reset-confirmed'
                        });
                    }
                    
                    // Show notification
                    showNotification("已同意重置請求，遊戲將重新開始");
                    
                    // Auto-start game after a brief delay
                    setTimeout(() => {
                        startGame();
                    }, 1000);
                });
                
                // Change the cancel button to reject
                const cancelButton = document.getElementById('confirm-cancel');
                if (cancelButton) {
                    cancelButton.textContent = "拒絕";
                    cancelButton.addEventListener('click', () => {
                        pendingResetRequest = false;
                        
                        // Send rejection to opponent
                        if (gameState.connection) {
                            gameState.connection.send({
                                type: 'reset-rejected'
                            });
                        }
                        
                        showNotification("已拒絕重置請求");
                    }, {once: true});
                }
                
            } else if (data.type === 'reset-confirmed') {
                // Opponent has confirmed our reset request
                showNotification("對手已同意重置遊戲，遊戲將重新開始");
                
                // Reset game
                initializeBoard();
                
                // Auto-start game after a brief delay
                setTimeout(() => {
                    startGame();
                }, 1000);
                
            } else if (data.type === 'reset-rejected') {
                // Opponent has rejected our reset request
                showNotification("對手拒絕了重置請求");
                
            } else if (data.type === 'start-game') {
                startGame();
            }
        }

        // Pending reset request state
        let pendingResetRequest = false;
        
        // Reset the game with dual confirmation
        function resetGame() {
            // If we already have a pending reset request from the opponent
            if (pendingResetRequest) {
                // We're confirming the opponent's request - do the actual reset
                pendingResetRequest = false;
                
                showNotification("重置請求已確認，遊戲將重新開始");
                
                // Actually reset the game
                initializeBoard();
                
                // Send confirmation back to opponent
                if (gameState.connection) {
                    gameState.connection.send({
                        type: 'reset-confirmed'
                    });
                }
                
                // Auto-start game after a brief delay
                setTimeout(() => {
                    startGame();
                }, 1000);
                
                return;
            }
            
            // Otherwise, we're initiating a new reset request
            showConfirmation('確定要申請重置遊戲嗎？需要對方同意才能重置。', () => {
                if (gameState.connection) {
                    // Send reset request to opponent
                    gameState.connection.send({
                        type: 'reset-request'
                    });
                    
                    showNotification("重置請求已發送，等待對手確認");
                }
            });
        }
        
        // Show custom confirmation dialog
        function showConfirmation(message, onConfirm) {
            // Create confirmation dialog if it doesn't exist
            let confirmDialog = document.getElementById('confirm-dialog');
            if (!confirmDialog) {
                confirmDialog = document.createElement('div');
                confirmDialog.id = 'confirm-dialog';
                confirmDialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                confirmDialog.style.display = 'none';
                
                const dialogContent = document.createElement('div');
                dialogContent.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg max-w-sm w-full';
                
                const messageElem = document.createElement('p');
                messageElem.id = 'confirm-message';
                messageElem.className = 'text-gray-800 dark:text-gray-200 mb-4';
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex justify-end space-x-2';
                
                const cancelButton = document.createElement('button');
                cancelButton.id = 'confirm-cancel';
                cancelButton.className = 'px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded';
                cancelButton.textContent = 'Cancel';
                
                const confirmButton = document.createElement('button');
                confirmButton.id = 'confirm-ok';
                confirmButton.className = 'px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded';
                confirmButton.textContent = 'Reset';
                
                buttonContainer.appendChild(cancelButton);
                buttonContainer.appendChild(confirmButton);
                dialogContent.appendChild(messageElem);
                dialogContent.appendChild(buttonContainer);
                confirmDialog.appendChild(dialogContent);
                document.body.appendChild(confirmDialog);
            }
            
            // Set message and show dialog
            const messageElem = document.getElementById('confirm-message');
            messageElem.textContent = message.replace('Are you sure you want to reset the game?', '確定要重置遊戲嗎？');
            confirmDialog.style.display = 'flex';
            
            // Set up button handlers
            const okButton = document.getElementById('confirm-ok');
            const cancelButton = document.getElementById('confirm-cancel');
            
            // Update button text to Chinese
            okButton.textContent = '重置';
            cancelButton.textContent = '取消';
            
            // Remove old event listeners
            const newOkButton = okButton.cloneNode(true);
            const newCancelButton = cancelButton.cloneNode(true);
            okButton.parentNode.replaceChild(newOkButton, okButton);
            cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
            
            // Add new event listeners
            newOkButton.addEventListener('click', () => {
                confirmDialog.style.display = 'none';
                onConfirm();
            });
            
            newCancelButton.addEventListener('click', () => {
                confirmDialog.style.display = 'none';
            });
        }

        // Toggle theme
        function toggleTheme() {
            document.documentElement.classList.toggle('dark-mode');
        }

        // Copy room ID to clipboard - simplified and guaranteed to work
        function copyRoomIdToClipboard() {
            const roomIdElement = document.getElementById('my-room-id');
            const copyText = roomIdElement.value;
            const copyButton = document.getElementById('copy-room-id');
            const originalText = copyButton.textContent;
            
            try {
                // Create a temporary textarea element - this approach works better in iframe environments
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = copyText;
                tempTextArea.style.position = 'fixed';  // Avoid scrolling to bottom
                tempTextArea.style.opacity = '0';
                document.body.appendChild(tempTextArea);
                tempTextArea.focus();
                tempTextArea.select();
                
                // Use the document.execCommand - most reliable in iframe environments
                const successful = document.execCommand('copy');
                document.body.removeChild(tempTextArea);
                
                if (successful) {
                    copyButton.textContent = '已複製!';
                    showNotification('房間ID已複製到剪貼板');
                } else {
                    // In case execCommand doesn't work, provide instructions
                    copyButton.textContent = '請選擇ID';
                    roomIdElement.focus();
                    roomIdElement.select();
                    showNotification('請手動選擇並複製房間ID');
                }
            } catch (err) {
                console.error('Copy failed:', err);
                copyButton.textContent = '請選擇ID';
                roomIdElement.focus();
                roomIdElement.select();
                showNotification('請手動選擇並複製房間ID');
            }
            
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 2000);
        }

        // Show different room views
        function showRoomView(view) {
            // Hide all views first
            document.getElementById('room-initial-view').classList.add('hidden');
            document.getElementById('room-created-view').classList.add('hidden');
            document.getElementById('room-join-view').classList.add('hidden');
            
            // Show the requested view
            if (view === 'initial') {
                document.getElementById('room-initial-view').classList.remove('hidden');
            } else if (view === 'created') {
                document.getElementById('room-created-view').classList.remove('hidden');
            } else if (view === 'join') {
                document.getElementById('room-join-view').classList.remove('hidden');
            }
        }

        // Event listeners for room views
        document.getElementById('create-room-btn').addEventListener('click', () => {
            initPeer();
        });
        
        document.getElementById('show-join-view-btn').addEventListener('click', () => {
            showRoomView('join');
        });
        
        document.getElementById('back-to-initial-btn').addEventListener('click', () => {
            showRoomView('initial');
            // Disconnect if there was a connection
            if (gameState.peer) {
                gameState.peer.destroy();
                gameState.peer = null;
            }
            if (gameState.connection) {
                gameState.connection.close();
                gameState.connection = null;
            }
            updateConnectionStatus('disconnected', '尚未連接');
        });
        
        document.getElementById('back-from-join-btn').addEventListener('click', () => {
            showRoomView('initial');
        });
        
        document.getElementById('join-room-btn').addEventListener('click', () => {
            const roomId = document.getElementById('room-id-input').value.trim();
            if (roomId) {
                connectToPeer(roomId);
            } else {
                showNotification('請輸入房間ID');
            }
        });

        document.getElementById('copy-room-id').addEventListener('click', copyRoomIdToClipboard);
        resetBtn.addEventListener('click', resetGame);

        // Listen for dark mode changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initializeBoard();
        });
    </script>


</body></html>